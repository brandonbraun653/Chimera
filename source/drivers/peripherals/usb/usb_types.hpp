/********************************************************************************
 *  File Name:
 *    usb_types.hpp
 *
 *  Description:
 *    Types for Chimera USB
 *
 *  2020 | Brandon Braun | brandonbraun653@gmail.com
 *******************************************************************************/

#pragma once
#ifndef CHIMERA_USB_TYPES_HPP
#define CHIMERA_USB_TYPES_HPP

/* STL Includes */
#include <cstdint>
#include <memory>

/* Chimera Includes */
#include <Chimera/common>
#include <Chimera/gpio>

namespace Chimera::USB
{
  /*-------------------------------------------------------------------------------
  Forward Declarations
  -------------------------------------------------------------------------------*/
  class Driver;

  /*-------------------------------------------------------------------------------
  Aliases
  -------------------------------------------------------------------------------*/
  using Driver_sPtr = std::shared_ptr<Driver>;


  /*-------------------------------------------------------------------------------
  Enumerations
  -------------------------------------------------------------------------------*/
  /**
   *  Physical hardware USB peripheral instances. These will be mapped to the
   *  corresponding device by the Chimera implementation.
   */
  enum class Channel : uint8_t
  {
    USB0,
    USB1,

    NUM_OPTIONS,
    UNKNOWN
  };


  /**
   *  Available endpoints that can be configured
   */
  enum class Endpoint : uint8_t
  {
    EP0,
    EP1,
    EP2,
    EP3,
    EP4,
    EP5,
    EP6,
    EP7,

    NUM_OPTIONS,
    UNKNOWN
  };


  /**
   *  Common data transfer types
   */
  enum class Transfer : uint8_t
  {
    BULK,
    CONTROL,
    ISOCHRONOUS,
    INTERRUPT,

    NUM_OPTIONS,
    UNKNOWN
  };

  /**
   *  Available interrupts generated in hardware
   */
  enum class Interrupt : uint8_t
  {
    ANY_ERROR,        /**< An error is indicated by hardware, see BusError */
    CORRECT_TRANSFER, /**< An endpoint successfully completed a transaction */
    LPM_REQ,          /**< A request was received to transition to Low Power mode */
    MISSING_SOF,      /**< USB expected SOF but never received it */
    PMA_OVER_UNDER,   /**< Packet memory area over/under ran */
    RESET,            /**< An active USB reset signal was detected */
    SUSPEND,          /**< No traffic received for 3ms */
    WAKEUP,           /**< During suspend mode, activity is detected to wake up */

    NUM_OPTIONS,
    UNKNOWN
  };


  /**
   *  Possible error conditions generated by hardware
   */
  enum class BusError : uint8_t
  {
    NO_ANSWER,    /**< Timeout for a host response has occurred */
    CRC,          /**< Some CRC was invalid */
    BIT_STUFF,    /**< A bit stuffing error was detected */
    FRAME_FORMAT, /**< A non-standard frame was received */

    NUM_OPTIONS,
    UNKNOWN
  };

  /*-------------------------------------------------------------------------------
  Structures
  -------------------------------------------------------------------------------*/
  struct Context
  {
  };


  /**
   *  Used to initialize an Endpoint
   */
  struct EndpointConfig
  {
  };


  /**
   *  Used to initialize the peripheral driver instance. This is focused
   *  on providing some very high level behavioral descriptions of what
   *  features the hardware should provide.
   */
  struct PeriphConfig
  {
    Channel channel;              /**< Which USB channel is being configured */
    bool useLPM;                  /**< Enable Low Power Mode support */
    bool useBattCharge;           /**< Enable battery charging support */
    Chimera::GPIO::PinInit pinDM; /**< DM pin configuration */
    Chimera::GPIO::PinInit pinDP; /**< DP pin configuration */

    void clear()
    {
      channel       = Channel::UNKNOWN;
      useLPM        = false;
      useBattCharge = false;

      pinDM.clear();
      pinDP.clear();
    }
  };


  namespace Backend
  {
    struct DriverConfig
    {
      bool isSupported;

      /**
       *  Initializes the backend driver's memory. Should really only call once for initial set up.
       *
       *  @return Chimera::Status_t
       */
      Chimera::Status_t ( *initialize )( void );

      /**
       *  Resets the backend driver hardware to default configuration
       *  settings, but does not wipe out any memory.
       *
       *  @return Chimera::Status_t
       */
      Chimera::Status_t ( *reset )( void );

      /**
       *  Factory function that creates a shared_ptr instance of the backend
       *  driver, as long as it conforms to the expected interface.
       *
       *  @return Driver_sPtr
       */
      Driver_sPtr ( *getDriver )( const Chimera::USB::Channel );
    };
  }  // namespace Backend
}  // namespace Chimera::USB

#endif /* !CHIMERA_USB_TYPES_HPP */
